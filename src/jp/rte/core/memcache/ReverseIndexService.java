package jp.rte.core.memcache;

import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.google.appengine.api.datastore.DatastoreService;
import com.google.appengine.api.datastore.DatastoreServiceFactory;
import com.google.appengine.api.datastore.DatastoreTimeoutException;
import com.google.appengine.api.datastore.Entity;
import com.google.appengine.api.datastore.FetchOptions;
import com.google.appengine.api.datastore.Query;
import com.google.appengine.api.memcache.MemcacheService;
import com.google.appengine.api.memcache.MemcacheServiceFactory;

public class ReverseIndexService {
    private static final String MC_KEY_COUNTER =
            "org.dotme.liquidtpl.service.ReverseIndexService#counter_";
        private static final String COUNTER_KEY = "c";
        private static final String COUNTER_KIND_PREFIX = "rc_";
        private static final int CLEANUP_AT_ONCE = 100;
        private static final MemcacheService mcService = MemcacheServiceFactory
            .getMemcacheService();

        private static Logger log = Logger.getLogger("ReverseIndexService");

        public static long increment(String name) {
            long countValue = 0L;
            // try to get the next value from Memcache
            try {
                countValue =
                    mcService.increment(MC_KEY_COUNTER + name, -1).longValue();
            } catch (Exception e) {
                log.log(Level.WARNING, "Failed to increment on Memcache: ", e);
                countValue = restoreCountValue(name);
            }

            // save a countValue by a ReverseCounterLog
            try {
                saveReverseCounterLog(countValue, name);
            } catch (DatastoreTimeoutException e) {
                log.log(Level.WARNING, "Failed to save ReverseCounterLog: ", e);
            }

            return countValue;
        }

        private static void saveReverseCounterLog(long countValue, String name) {
            DatastoreService datastoreService =
                DatastoreServiceFactory.getDatastoreService();
            Entity e =
                new Entity(new StringBuilder()
                    .append(COUNTER_KIND_PREFIX)
                    .append(name)
                    .toString());
            e.setProperty(COUNTER_KEY, Long.toString(countValue));
            datastoreService.put(e);
        }

        public static long restoreCountValue(String name) {
            DatastoreService datastoreService =
                DatastoreServiceFactory.getDatastoreService();
            List<Entity> cls =
                datastoreService.prepare(
                    new Query(new StringBuilder()
                        .append(COUNTER_KIND_PREFIX)
                        .append(name)
                        .toString()).addSort(
                        COUNTER_KEY,
                        Query.SortDirection.ASCENDING)).asList(
                    FetchOptions.Builder.withLimit(1));

            long countValue =
                (cls == null) || (cls.size() == 0) ? Long.MAX_VALUE : Long
                    .valueOf((((Entity) cls.get(0)).getProperty(COUNTER_KEY)
                        .toString())) - 1L;

            mcService.put(new StringBuilder()
                .append(MC_KEY_COUNTER)
                .append(name)
                .toString(), countValue);

            log.log(
                Level.WARNING,
                new StringBuilder()
                    .append("Restored count value: ")
                    .append(countValue)
                    .toString());

            return countValue;
        }

        public static void deleteCountValueOnMemcache(String name) {
            mcService.delete(new StringBuilder()
                .append(MC_KEY_COUNTER)
                .append(name)
                .toString());
        }

        public static void cleanupDatastore(String name) {
            Boolean isFirst = true;
            DatastoreService datastoreService =
                DatastoreServiceFactory.getDatastoreService();

            List<Entity> list =
                datastoreService.prepare(
                    new Query(new StringBuilder()
                        .append(COUNTER_KIND_PREFIX)
                        .append(name)
                        .toString()).addSort(
                        COUNTER_KEY,
                        Query.SortDirection.ASCENDING)).asList(
                    FetchOptions.Builder.withLimit(CLEANUP_AT_ONCE));

            for (Entity e : list) {
                if (isFirst) {
                    datastoreService.delete(e.getKey());
                }
                isFirst = false;
            }
        }

        public static void delete(String name) {
            mcService.delete(new StringBuilder()
                .append(MC_KEY_COUNTER)
                .append(name)
                .toString());
            DatastoreService datastoreService =
                DatastoreServiceFactory.getDatastoreService();

            List<Entity> list =
                datastoreService.prepare(
                    new Query(new StringBuilder()
                        .append(COUNTER_KIND_PREFIX)
                        .append(name)
                        .toString()).addSort(
                        COUNTER_KEY,
                        Query.SortDirection.ASCENDING)).asList(
                    FetchOptions.Builder.withLimit(CLEANUP_AT_ONCE));

            for (Entity e : list) {
                datastoreService.delete(e.getKey());
            }
        }


}
